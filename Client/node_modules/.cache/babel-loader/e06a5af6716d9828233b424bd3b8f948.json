{"ast":null,"code":"import React from 'react';\nimport { notifyManager } from '../core/notifyManager';\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary';\nimport { useQueryClient } from './QueryClientProvider';\nexport function useBaseQuery(options, Observer) {\n  var mountedRef = React.useRef(false);\n\n  var _React$useState = React.useState(0),\n      forceUpdate = _React$useState[1];\n\n  var queryClient = useQueryClient();\n  var errorResetBoundary = useQueryErrorResetBoundary();\n  var defaultedOptions = queryClient.defaultQueryObserverOptions(options); // Make sure results are optimistically set in fetching state before subscribing or updating options\n\n  defaultedOptions.optimisticResults = true; // Include callbacks in batch renders\n\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(defaultedOptions.onError);\n  }\n\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(defaultedOptions.onSuccess);\n  }\n\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(defaultedOptions.onSettled);\n  }\n\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000;\n    }\n  }\n\n  if (defaultedOptions.suspense || defaultedOptions.useErrorBoundary) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      defaultedOptions.retryOnMount = false;\n    }\n  }\n\n  var obsRef = React.useRef();\n\n  if (!obsRef.current) {\n    obsRef.current = new Observer(queryClient, defaultedOptions);\n  }\n\n  var result = obsRef.current.getOptimisticResult(defaultedOptions);\n  React.useEffect(function () {\n    mountedRef.current = true;\n    errorResetBoundary.clearReset();\n    var unsubscribe = obsRef.current.subscribe(notifyManager.batchCalls(function () {\n      if (mountedRef.current) {\n        forceUpdate(function (x) {\n          return x + 1;\n        });\n      }\n    })); // Update result to make sure we did not miss any query updates\n    // between creating the observer and subscribing to it.\n\n    obsRef.current.updateResult();\n    return function () {\n      mountedRef.current = false;\n      unsubscribe();\n    };\n  }, [errorResetBoundary]);\n  React.useEffect(function () {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    obsRef.current.setOptions(defaultedOptions, {\n      listeners: false\n    });\n  }, [defaultedOptions]); // Handle suspense\n\n  if (defaultedOptions.suspense && result.isLoading) {\n    throw obsRef.current.fetchOptimistic(defaultedOptions).then(function (_ref) {\n      var data = _ref.data;\n      defaultedOptions.onSuccess == null ? void 0 : defaultedOptions.onSuccess(data);\n      defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(data, null);\n    }).catch(function (error) {\n      errorResetBoundary.clearReset();\n      defaultedOptions.onError == null ? void 0 : defaultedOptions.onError(error);\n      defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(undefined, error);\n    });\n  } // Handle error boundary\n\n\n  if ((defaultedOptions.suspense || defaultedOptions.useErrorBoundary) && result.isError && !result.isFetching) {\n    throw result.error;\n  } // Handle result property usage tracking\n\n\n  if (defaultedOptions.notifyOnChangeProps === 'tracked') {\n    result = obsRef.current.trackResult(result);\n  }\n\n  return result;\n}","map":{"version":3,"sources":["C:/Users/Dear User/Desktop/Resturant/resturantalpha/Client/node_modules/react-query/es/react/useBaseQuery.js"],"names":["React","notifyManager","useQueryErrorResetBoundary","useQueryClient","useBaseQuery","options","Observer","mountedRef","useRef","_React$useState","useState","forceUpdate","queryClient","errorResetBoundary","defaultedOptions","defaultQueryObserverOptions","optimisticResults","onError","batchCalls","onSuccess","onSettled","suspense","staleTime","useErrorBoundary","isReset","retryOnMount","obsRef","current","result","getOptimisticResult","useEffect","clearReset","unsubscribe","subscribe","x","updateResult","setOptions","listeners","isLoading","fetchOptimistic","then","_ref","data","catch","error","undefined","isError","isFetching","notifyOnChangeProps","trackResult"],"mappings":"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","sourcesContent":["import React from 'react';\nimport { notifyManager } from '../core/notifyManager';\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary';\nimport { useQueryClient } from './QueryClientProvider';\nexport function useBaseQuery(options, Observer) {\n  var mountedRef = React.useRef(false);\n\n  var _React$useState = React.useState(0),\n      forceUpdate = _React$useState[1];\n\n  var queryClient = useQueryClient();\n  var errorResetBoundary = useQueryErrorResetBoundary();\n  var defaultedOptions = queryClient.defaultQueryObserverOptions(options); // Make sure results are optimistically set in fetching state before subscribing or updating options\n\n  defaultedOptions.optimisticResults = true; // Include callbacks in batch renders\n\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(defaultedOptions.onError);\n  }\n\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(defaultedOptions.onSuccess);\n  }\n\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(defaultedOptions.onSettled);\n  }\n\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000;\n    }\n  }\n\n  if (defaultedOptions.suspense || defaultedOptions.useErrorBoundary) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      defaultedOptions.retryOnMount = false;\n    }\n  }\n\n  var obsRef = React.useRef();\n\n  if (!obsRef.current) {\n    obsRef.current = new Observer(queryClient, defaultedOptions);\n  }\n\n  var result = obsRef.current.getOptimisticResult(defaultedOptions);\n  React.useEffect(function () {\n    mountedRef.current = true;\n    errorResetBoundary.clearReset();\n    var unsubscribe = obsRef.current.subscribe(notifyManager.batchCalls(function () {\n      if (mountedRef.current) {\n        forceUpdate(function (x) {\n          return x + 1;\n        });\n      }\n    })); // Update result to make sure we did not miss any query updates\n    // between creating the observer and subscribing to it.\n\n    obsRef.current.updateResult();\n    return function () {\n      mountedRef.current = false;\n      unsubscribe();\n    };\n  }, [errorResetBoundary]);\n  React.useEffect(function () {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    obsRef.current.setOptions(defaultedOptions, {\n      listeners: false\n    });\n  }, [defaultedOptions]); // Handle suspense\n\n  if (defaultedOptions.suspense && result.isLoading) {\n    throw obsRef.current.fetchOptimistic(defaultedOptions).then(function (_ref) {\n      var data = _ref.data;\n      defaultedOptions.onSuccess == null ? void 0 : defaultedOptions.onSuccess(data);\n      defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(data, null);\n    }).catch(function (error) {\n      errorResetBoundary.clearReset();\n      defaultedOptions.onError == null ? void 0 : defaultedOptions.onError(error);\n      defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(undefined, error);\n    });\n  } // Handle error boundary\n\n\n  if ((defaultedOptions.suspense || defaultedOptions.useErrorBoundary) && result.isError && !result.isFetching) {\n    throw result.error;\n  } // Handle result property usage tracking\n\n\n  if (defaultedOptions.notifyOnChangeProps === 'tracked') {\n    result = obsRef.current.trackResult(result);\n  }\n\n  return result;\n}"]},"metadata":{},"sourceType":"module"}